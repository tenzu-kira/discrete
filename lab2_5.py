def count_paths(n, m):
    # Инициализация таблицы dp
    # dp[i][j][0] — последний шаг горизонтальный
    # dp[i][j][1] — последний шаг вертикальный
    dp = [[[0, 0] for _ in range(m + 1)] for _ in range(n + 1)]

    # Базовый случай: начальная точка (0, 0)
    dp[0][0][0] = 1  # Можно считать, что мы "пришли" горизонтально
    dp[0][0][1] = 1  # Или вертикально

    # Заполняем таблицу
    for i in range(n + 1):
        for j in range(m + 1):
            if i == 0 and j == 0:
                continue  # Начальная точка уже обработана

            # Если приходим горизонтально (из (i-1, j))
            if i > 0:
                dp[i][j][0] += dp[i - 1][j][0] + dp[i - 1][j][1]

            # Если приходим вертикально (из (i, j-1)), но только если предыдущий шаг не был вертикальным
            if j > 0:
                dp[i][j][1] += dp[i][j - 1][0]  # Только если предыдущий шаг был горизонтальным

    # Общее количество путей — сумма путей, заканчивающихся горизонтальным и вертикальным шагом
    return dp[n][m][0] + dp[n][m][1]

def count_paths_reg(m, n):
    dp = [1] * (n + 1)

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[j] += dp[j - 1]

    return dp[n]


# Размер сетки
n = 21  # горизонтальные линии
m = 18  # вертикальные линии

# Вычисляем количество путей
result = count_paths(n, m)
print("Счет без учета ограничений:", count_paths_reg(n, m))
print(f"Количество путей без двух последовательных вертикальных участков: {result}")
